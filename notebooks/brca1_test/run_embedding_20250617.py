# Run Evo2 for pilot study
# H200 (1 and 2 GPU configurations, 144 GB each)
# H100 (2 GPU configuration, 80 GB each)

# WINDOW_SIZE="1024 2048 4096 8192"
# SEQ_LENGTH="10 50 84 150 250 500 1000 2000"
# MODEL_SIZE="7b"

# for ws in $WINDOW_SIZE; do
#   for sl in $SEQ_LENGTH; do
#     echo "Running: run_evo2_20250617.py -SEQ_LENGTH $sl -WINDOW_SIZE $ws -MODEL_SIZE $MODEL_SIZE"
#     python run_evo2_20250617.py --SEQ_LENGTH $sl --WINDOW_SIZE $ws --MODEL_SIZE $MODEL_SIZE
#   done
# done

pip install matplotlib pandas seaborn scikit-learn openpyxl biopython

# Docker image
# nvcr.io/nvidia/clara/bionemo-framework:2.5

import glob
import gzip
import json
import math
import os
from pathlib import Path
import time
import openpyxl
import subprocess
import warnings
warnings.simplefilter("ignore", FutureWarning)

import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import torch
from Bio import SeqIO
from sklearn.metrics import auc, roc_auc_score, roc_curve
FAST_CI_MODE: bool = os.environ.get("FAST_CI_MODE", False)

######################### ######################## ########################
# Load arguments
import argparse
parser = argparse.ArgumentParser(description="Evo2 pilot study")
parser.add_argument("--SEQ_LENGTH", type=int, required=True, default=100, help="SEQ_LENGTH")
parser.add_argument("--WINDOW_SIZE", type=int, required=True, default=4096, help="Window size")
parser.add_argument("--MODEL_SIZE", type=str, help="MODEL_SIZE")
args = parser.parse_args()
OUTPUT_DIR = "brca1_fasta_files"
DATA_DIR = "brca1"
SEQ_LENGTH = args.SEQ_LENGTH
WINDOW_SIZE = args.WINDOW_SIZE
MODEL_SIZE = args.MODEL_SIZE

########################################################################
# Define functions 
########################################################################
# Initialize the metrics files if they don't already exist
def initialize_metrics_file():
    metrics_xlsx = Path("metrics.xlsx")
    metrics_csv = Path("metrics.csv")
    
    if not metrics_xlsx.exists() or not metrics_csv.exists():
        # Create a blank DataFrame with the specified columns
        columns = [
            "MODEL_SIZE", "SEQ_LENGTH", "WINDOW_SIZE", 
            "load_model", "model_prep", "score_ref", "score_var", "delta", "AUROC"
        ]
        df = pd.DataFrame(columns=columns)
        # Write to both .xlsx and .csv files
        if not metrics_xlsx.exists():
            df.to_excel(metrics_xlsx, index=False)
        if not metrics_csv.exists():
            df.to_csv(metrics_csv, index=False)
    return metrics_xlsx, metrics_csv

# Append results to both .xlsx and .csv files
def append_metrics_row(metrics_files, row_data):
    metrics_xlsx, metrics_csv = metrics_files
    
    # Update the .xlsx file
    df_xlsx = pd.read_excel(metrics_xlsx)
    df_xlsx = pd.concat([df_xlsx, pd.DataFrame([row_data])], ignore_index=True)
    df_xlsx.to_excel(metrics_xlsx, index=False)
    
    # Update the .csv file
    df_csv = pd.read_csv(metrics_csv)
    df_csv = pd.concat([df_csv, pd.DataFrame([row_data])], ignore_index=True)
    df_csv.to_csv(metrics_csv, index=False)

def sample_data(df, sample_frac=1.0, balanced=True, disable=True, random_state=42):
    """Sample dataframe, optionally with balanced classes.
    Parameters:
    -----------
    df : pandas.DataFrame
        Input dataframe
    sample_frac : float
        Fraction of data to sample
    balanced : bool
        Whether to balance classes
    disable : bool
        Whether to disable sampling
    random_state : int
        Random seed for reproducibility
    Returns:
    --------
    pandas.DataFrame
        Sampled dataframe
    """
    if disable:
        return df
    if balanced:
        # Get the number of rows in the dataframe
        num_rows_minor_class = math.ceil(len(df[df["class"] == "LOF"]) * sample_frac)
        return (
            pd.concat(
                [
                    df[df["class"] == "LOF"].sample(n=num_rows_minor_class, random_state=random_state),
                    df[df["class"] == "FUNC/INT"].sample(n=num_rows_minor_class, random_state=random_state),
                ]
            )
            .sample(frac=1.0, random_state=random_state)
            .reset_index(drop=True)
        )
    else:
        # Calculate the number of rows to sample
        return df.sample(frac=sample_frac, random_state=random_state).reset_index(drop=True)

# Write a function that takes in seq (variable storing one an integer) and randomly subsets the dataframe (df) to SEQ_LENGTH number of rows and returns the saubset of the dataframe 
def subset_dataframe(df, seq):
    """
    Randomly subsets the dataframe to SEQ_LENGTH number of rows.
    Parameters:
    -----------
    df : pandas.DataFrame
        The input dataframe to subset.
    SEQ_LENGTH : int
        The number of rows to subset the dataframe to.
    Returns:
    --------
    pandas.DataFrame
        A subset of the dataframe with SEQ_LENGTH rows.
    """
    print("Number of rows to extract:", seq) 
    if seq > len(df):
        raise ValueError(f"SEQ_LENGTH ({seq}) is greater than the number of rows in the DataFrame ({len(df)}).")
    subset_df = df.sample(n=seq, random_state=42)
    print("New subset:", subset_df.shape) 
    return subset_df

def parse_sequences(pos, ref, alt, seq_chr17, window_size=WINDOW_SIZE):
    """Parse reference and variant sequences from the reference genome sequence.
    Parameters:
    -----------
    pos : int
        Position (1-indexed)
    ref : str
        Reference base
    alt : str
        Alternate base
    seq_chr17 : str
        Full chromosome 17 sequence
    window_size : int
        Size of the sequence window to extract

    Returns:
    --------
    tuple
        (reference_sequence, variant_sequence)
    """
    p = pos - 1  # Convert to 0-indexed position
    full_seq = seq_chr17
    ref_seq_start = max(0, p - window_size // 2)
    ref_seq_end = min(len(full_seq), p + window_size // 2)
    ref_seq = seq_chr17[ref_seq_start:ref_seq_end]
    snv_pos_in_ref = min(window_size // 2, p)
    var_seq = ref_seq[:snv_pos_in_ref] + alt + ref_seq[snv_pos_in_ref + 1 :]

    # Sanity checks
    assert len(var_seq) == len(ref_seq)
    assert ref_seq[snv_pos_in_ref] == ref
    assert var_seq[snv_pos_in_ref] == alt
    return ref_seq, var_seq

############################################################
# load input data
############################################################

# 2. Load and preprocess variant data
brca1_df = load_brca1_data(excel_path)
print("Dimensions of brca1_df:", brca1_df.shape) # Dimensions of brca1_df: (3893, 6)

# 3. Subset data using subset_dataframe()
brca1_df = subset_dataframe(brca1_df,SEQ_LENGTH)
brca1_df.head(2)
print("Loaded df:", brca1_df.shape)


################################################
# Input model
################################################
from helical.models.evo_2 import Evo2, Evo2Config
evo2_config = Evo2Config(batch_size=1)  # Configure Evo2
evo2 = Evo2(configurer=evo2_config)
evo2.model

################################################
# Generate emebeddings framework 
################################################
input_sequences = ["ACGT" * 1000]


# Hypothetical BRCA1 ref and var sequences (variant T>A at position 8, total 17 nucleotides in length)
input_sequences = ["ATGCAGGCTTGCCTTCT", "ATGCAGGCATGCCTTCT"]

# Print the number of letters in each string in input_sequences
for i, seq in enumerate(input_sequences):
    print(f"Sequence {i + 1}: {len(seq)} letters")
    
dataset = evo2.process_data(input_sequences)
embeddings = evo2.get_embeddings(dataset)

# Print to check 
for i, seq in enumerate(input_sequences):
    last_embedding = embeddings["embeddings"][i][embeddings["original_lengths"][i] - 1]
    print(f"Last embedding for sequence {i + 1}: {last_embedding}")
    print(f" Dim: {last_embedding.shape}")

# Extract the embeddings for sequence 1 and sequence 2
embedding_1 = embeddings["embeddings"][0][0]  # Sequence 1 embedding (first and only row in embedding)
embedding_2 = embeddings["embeddings"][1][0]  # Sequence 2 embedding (first and only row in embedding)

# Ensure embeddings are 1D for comparison
assert embedding_1.shape == embedding_2.shape, "Embeddings must have the same shape!"
embedding_1 = embedding_1.flatten()
embedding_2 = embedding_2.flatten()

################################################
# save embeddings
################################################

input_name="BRCA1"
SEQ_LENGTH="8192"
out_name = f"{input_name}_seq{SEQ_LENGTH}"
current_dir = os.getcwd()
print(f"Current directory: {current_dir}")

# Convert embeddings to NumPy arrays and save
numpy_embeddings = []
for i, seq in enumerate(input_sequences):
    last_embedding = embeddings["embeddings"][i][embeddings["original_lengths"][i] - 1]
    numpy_embeddings.append(last_embedding)
    np.save(f"{out_name}_embed.npy", numpy_embeddings)
# Load the embeddings from the .npy file
loaded_embeddings = np.load(f"{out_name}_embed.npy", allow_pickle=True)
print(f"Number of embeddings: {len(loaded_embeddings)}")
print(f"  loaded_embeddings: {loaded_embeddings.shape}") #  loaded_embeddings: (2, 1, 4096)
for i, embedding in enumerate(loaded_embeddings):
    print(f"Embedding {i + 1}:")
    print(f"  Shape: {embedding.shape}")
    print(f"  Data:\n{embedding}\n")

region="BRCA1"
input_file=f"RovHer_{region}.txt"
chr="17"
################################################
# 1. Load reference file
################################################

ref_file = f"GRCh38_chr{chr}.fasta"
refseq = str(next(SeqIO.parse(open(ref_file, "rt"), "fasta")).seq)
print(len(refseq))  # 83257441

################################################
# 2. Load SNV dataset from local environment
################################################

# Check if file exists
data = pd.read_csv(input_file, sep="\t")  # Assuming the file is tab-delimited

# Split the `PLINK_SNP_NAME` column into 4 new columns: chrom, pos, ref, alt
data[["chrom", "pos", "ref", "alt"]] = data["PLINK_SNP_NAME"].str.split(":", expand=True)
data["pos"] = data["pos"].astype(int)

# Rename the column LOF_DISRUPTIVE to class
data.rename(columns={"LOF_DISRUPTIVE": "class"}, inplace=True)
data["class"] = data["class"].replace({0: "FUNC/INT", 1: "LOF"})


# BRCA1 ref seq
ref = "TTAAACACTTTTCAAACCAGGCAATATTTTAGGCCTACTGTATATTTGCATTTTGAGCTTCCAATACGGATAAGTGACTGGAAAAAGCAGCTAGGTTTAGGTTGAAAAACAACAACCCACCGGGGAACACATTTTAGCAAATTCTTCTGAAAGTCAAAAATGTTATAGTCATAGGTAAAAAGTTACAAAGAACTACCAATTGTCAGAAATAGCTGCCAATATTGACTTAGAAGACAGCAGAAGGAATTTTAGTTCAAGAAACCTAAAACAGGCTGAAAACCTTACCTACCCTATAGCTACCACAAATAACACTGTTTCCAGTCATGATCATTCCTGATCACATATTAAGACATAACTGCAAATTGTGCTATACTGTACTATATTAAAAGGAAGTGAAATATGATCCCTATCCTAGAACTTTCCATACAAATGAATGTAAAACACCATAAAAATTAATCTTAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGTGGGCGGATCACGAGGTCAGGAAGTGGAGACCATCCTGGCTAACACGGTGAAACCCCGTCTCTACTAAAAATACAAAAAATTAGCCGGGCGTGGTGGTGGACGCCTGTAGTCCCAGCTACTTGGGGGGCCGAGGCAGGAGAATGGCGTGAACCCGGGAGGCGGAGCTTGCAGTGAGCCGAGATGGCGCCACTGCACTCCGGCCTGGGTGAAAGAGCGAGACTCCGTCTCAAAAACAAAACAAACAAAAATTAATCTTAAGCCAGGCGCAGTGGCTCACGCCAGCACTTTGGAAGGCCGAGGCGGGTGGATCACGAGATCAGGACTTCAAGACCAGCCTGACCAACGTGATGAAACCCTATCTCTACTAAAAATACAAAATTAGCCGGCCACGGTGGCGTGCGCCTATAATCCCAGCTACTCAGGAGGCTGAGGCAGGAGAAGCGCTTGAACTTGAACCTGGCAGGCGGAGGTTGCAGTGAGCCAAGATGGCGCCACTGCACTCCAGCCTGGGCGACAGAGCCAGACTCCAACCCCCCACCCCGAAAAAAAAAGGTCCAGGCCGGGCGCAGTGGCTCAGGACTGTAATCCCAGCACTTTGGAAGGCTGAGGCGGGTGGATCACAAGGTCAGGAGATCGAGACCATCTTGGCTAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAAATTAGCCGGGCATAGTGGTGGGCGCCTGTAGTCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATGGCCTGAACCCGGGAGGCGGAGCTGGCAGTGAGCCAAGATCGTGCCACTGCACTCCAGCCTAGGCAGCAGAGCGAGACCGTGTCTCAAAAAAACAAAACAAAACAAAACAAAAAGTCTGGGAGCGGTGGCTCACGCCTGTAATCCCAGCACTTTCGGAGGCCAAGGCAGGAGGATCACCTGAGGTCAGGAGTTCGAGACCAACCTGACCAATATGGAGAAACCCTGTCTCTACTAAAAATACAAAATTAGCTGGTGTGATGGCACATGCCTGCAATCCCAGGTACTCCGGAGGCTGAGGCAGCAGAATTGCTTGAACCCGGGAGGTGGAGGTTGTAGTGAGCCGAGATTGTGCCACTGCACTCCAGCCTGGGCAACAAGAGCCAAAGTCTGTCTCAAAAAAAAAAAAAAAAAAAAAAAAAGAAATTAATCTTAACAGGAAACAGAAAAAAGCAATGAAAAGCTAGAAAACATAATAGTTGATTGAAAATAACAATTTAGCATTTTCATTCTTACATCTTTAATTTTTATGTATCTGAGTTTTTAATTGATGGTTTAATTTGCCAGAATGAGAAAGAACATCCTATTTTTATGACTCTCTCCCATGGAAATGAAACATAAATGTATCCAAATGCCACACTATTGAGGATTTTCCTGATCACTGATTGTCATGAGTAAGTTTTGTGCTTTTTCAAAAGCAGTTTTTTCCTACAATGTCATTTCCTGCTTCTCTGGCTCTGATTTTCAATAAATTGATAAATTGTGAATCCTGTTTTCCTCTTATTTTTGTTTAGCTATAATGTTGAAGGGCAAGGGAGAGGATGGTTATTTATAAATCTTGTATCGCTCTGAAAACACAACATACATTTTCCTTAATCTGATTAACTTGACTTCAAATATGAAAAACAACTTTCATAAAGCAGAAAAGAATTTACCCTTTTTTATTGTGGGTAAGAGGCAATGGTACAACTTTTCAACTTATTTTTTGAATGTTACTCACTACTAACCATCACCATATTTAAAAAAATTAAAGAACTAATTTAGTTTAGTTTATTATTTATTTGACAAATGTTTATTGAGTGGCAACTAGGTCCCAAGTACCGTTCTAACTACTGAACATACAGATGTATGTAAACAAAACAAAAATCCCATCCTGGAGTTTACATTCTGTGGGACTAGAGATAAAAAATGGATACATTACATAGAATGTCAGCTAGTAATCAGTGTTATGGAGAAGCAGCAGGAATAGAAGATAAAGTGTGTGCTGGGGGTGTGGTAATTTTAAATAGGGGTGTCTGGAAATGAAAAGGTGGTATTTCAATCAAGATTTTTAGACCATGGCTGGGTGCAATGGCTCAGGCCTGTAATCCCAGCACCTTGAGAGGCCAAGGGAGGGTAGATCACTTGAGGTCAGGAGTTTGAGACCAGCATGGCCAACATAGCAAAACCCTATCTCTACAACAGAAAAATACAAGAATGGCTGGACGCAGTGGCTTATGCCTGTAATCCTAGCACTTTGGGAGGCCCAGGCGGGTGGATCACAAGGTCAGGAGATCAAGACTATCCTGGCTAACACGGTGAAATCCCGCCTCTACTAAAAAAGAAAAAAAAATACAAAAAATTAGCCGGGCGTGGTAGTGGGTGCTTGTAGTCCCAGCTATTCAGGAGGCTCAGGCAGAAGAATGGCATGAACCCGGGAGGCAGAGTTTGCAGTGAGCTGAGATCGCGCCACTGCACTCCAGCCTGGGCAACAGAGCAAGACTCCATCTCAAAAAAAGAAAAAAAAATACAAAAATTAGCTGGGCATGGTGGTGCACACCTATCGTCCCTGCTACTCTGGAGGCTGAGGTGGGAGGATTGCTTGAGCCTGACGAGGTTGAGGCTGCAGTGAGCTGTGATAGCACCACTGCACTCCAGCCTCTCGACAGAGATCCTATATAAAAAAAAAACCTCTGCATTTCATTGTATGTAAATAAGTATGTAATTTCATTGTATGTACAGAGCCAGTTTCAAACAAAGGTTCTTCCAAATACCTATCCTCTCAACGACACCGATCATCCATGTTTTTTTTTTTTTTTTTTTTTTTTTGAGATGGAGTTTAGCTCTGTCGCTGGAGTTCAGTGGTGCCATATTGGCTCACAGCAACATCTGCCTCCTGGTTCAAGTGATTCTCCTGCCTCAGCCTCCTGAGTAGCTGGGATTACAGGCACATGCCACTACGCCCAGCTAATTTTTGTATTTTTAGTGGAGAGGGGGTTTCACCATGTTGGCCAGGATGGTCTCGATCTCCTGACCTCGTGATCCTACCACCTTGGCCTCCCAAAGTGCTGGGATTACAGGCATAAGCCACCGCCCTCGGCCTCATCCATGATTTTATTTTGCCATTTCAAGTGATGGAGCTTGTTTTAGAGCTGGAAGAAAAGCCAAAATGCCAGTTAATCTAAACTAGATTCCTGCCCCAGTGCAGAACCAATCAAGACAGAGTCCCTGTCTTTCCCGGACCACAGGATTTGTGTTGAAAAGGAGAGGAGTGGGAGAGGCAGAGTGGATGGAGAACAAGGAATCATTTTCTATATTTTTAAAGTTCTTCAGTTAAGAAAATCAGCAATTACAATAGCCTAATCTTACTAGACATGTCTTTTCTTCCCTAGTATGTAAGGTCAATTCTGTTCATTTGCATAGGAGATAATCATAGGAATCCCAAATTAATACACTCTTGTGCTGACTTACCAGATGGGACACTCTAAGATTTTCTGCATAGCATTAATGACATTTTGTACTTCTTCAACGCGAAGAGCAGATAAATCCATTTCTTTCTGTTCCAATGAACTTTAACACATTAGAAAAACATATATATATATCTTTTTAAAAGGTTTATAAAATGACAACTTCATTTTATCATTTTAAAATAAAGTAAATTTAAGATTTGGAAGGTTTTAGAATAATACAAACCAAAGAACTAATGACAACGTCCTTTATTTTTAAAGATTCTAGAAGTTGCTTTTTGTAATTAGACAACATAAATTCTGAATTTTTTCACATATTGCTGCCAACCCCTTGGGTCTTTTCCTTTCTCCAAGAAAGAGAAAGCTACAGAGGAGTGACTGACCGGGTAGGTGGTGGTAGCCTTAGCTTTCTCCAATGTTTCTGGTTGTTTTCTTTTTCTTGCATAAAACCAAAATCAACAACGACCAAACCAACACCAATCAAGGCCTCCCCGCCCCTAACCTTTCCCAGTGACCTGCTCTCATCTCTGGATCCTCCTCAAGCACATCCCTGCCGGCAGCATCTGTTACTACTGACGCTCCTCTACTTCCCTCTTGCGCTTTCTCAATGGCGCAAATGGATCCAGTTCTTAAGTTCTCCCTCCCACAAAATCCTGTCTCCTCCCCTTCCCAGACATATTCCTGGCACCTCTTCTTCCACAAGGTCCCATCCTCTCATACATACCAGCCGGTGTTTTTTGTTTTGTTTTGTTTTGTTTTGTTTTGAGACAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAATGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCTAGCGATTCTCCTGCCTCAGCCTCCTGAGTAGCTGGAGCGGCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGAGTTTCACCACGTTGGTCAGGCTGGTCTGGAACTCCTGACCTCATGACCAGCCGACGTTTTTAAAGACATAGTGTCCCCCTCAAGGCATATTCCAGTTCCTATCACGAGGATTCCCCCACGGACACTCAGTGCCCCCTTCCTGATCCTCAGCGCTTCCCTCGCGACCTACAAACTGCCCCCCTCCCCAGGGTTCACAACGCCTTACGCCTCTCAGGTTCCGCCCCTACCCCCCGTCAAAGAATACCCATCTGTCAGCTTCGGAAATCCACTCTCCCACGCCAGTACCCCAGAGCATCACTTGGGCCCCCTGTCCCTTTCCCGGGACTCTACTACCTTTACCCAGAGCAGAGGGTGAAGGCCTCCTGAGCGCAGGGGCCCAGTTATCTGAGAAACCCCACAGCCTGTCCCCCGTCCAGGAAGTCTCAGCGAGCTCACGCCGCGCAGTCGCAGTTTTAATTTATCTGTAATTCCCGCGCTTTTCCGTTGCCACGGAAACCAAGGGGCTACCGCTAAGCAGCAGCCTCTCAGAATACGAAATCAAGGTACAATCAGAGGATGGGAGGGACAGAAAGAGCCAAGCGTCTCTCGGGGCTCTGGATTGGCCACCCAGTCTGCCCCCGGATGACGTAAAAGGAAAGAGACGGAAGAGGAAGAATTCTACCTGAGTTTGCCATAAAGTGCCTGCCCTCTAGCCTCTACTCTTCCAGTTGCGGCTTATTGCATCACAGTAATTGCTGTACGAAGGTCAGAATCGCTACCTATTGTCCAAAGCAGTCGTAAGAAGAGGTCCCAATCCCCCACTCTTTCCGCCCTAATGGAGGTCTCCAGTTTCGGTAAATATAAGTAATAAGGATTGTTGGGGGGGTGGAGGGAAATAATTATTTCCAGCATGCGTTGCGGAATGAAAGGTCTTCGCCACAGTGTTCCTTAGAAACTGTAGTCTTATGGAGAGGAACATCCAATACCAGAGCGGGCACAATTCTCACGGAAATCCAGTGGATAGATTGGAGACCTGTGCGCGCTTGTACTTGTCAACAGTTATGGACTGGAGTGTTATGTTTTCGTATTTTGAAAGCAGAAACTAGGCCTTAAAAAGATACGTACAACTCTTTAGGGAGACTACAATTCCCATCCAGCCCCAGGAGTCTGGGGCAAGTAGTCTTGTAAGGTCAGTGGCCTGCGGGGACGCAGTGAGCGCCGAATTTGCCTGGGGCAGGGGAAATGCGCTCTGGCCCATGTCTGCGCACTCGTAGTTCCACCCCTCAGCCCCAGTGTTTGTTATTTTTCGGGTTCAGCTTGCTTTTGCCCCGTCTCCGTCGACGCAATCGCCACCAGTCAATGGGGTGGTCGTTTTGAGGGACAAGTGGTAAGAGCCAATCTTCTTGGCGAAAACGCGGAGAAACGGGACTAGTTACTGTCTTTGTCCGCCATGTTAGATTCACCCCACAGAGATAGCGGCAGAGCTGGCAGCGGACGGTCTTTGCATTGCCGCCTCCCCAGGGGGCGGGAAGCTGGTAAGGAAGCAGCCTGGGTTAGCTAGGGGTGGGGTCACGTCACACTAAGAGGGTTTGGAGAAGTTCAAGGGAGGAATCCTGCAAAGAAGAGGGGCGACTTTTTCCGTGTCTCCGGACAGCTAATCGTTTTAGTGACAGGATGAGAGAGCCCTTCGTGTTCTGAGGGACCGAGTGGGCGAAAAGCGCCGGAGAGTTGGAGAGTCTGTGGTTCAGAATGCGAGGTGACAACGTGCTAGCAGCCCTCGCTCGCTCTCGGCGCCTCCTCGGCCTTGGCGTCCATTCTGGCCGTGCTGGAGGAGCCCTTCAGCCCGCCACTGCGCTGTGGGGGCCCCTCTCTGGGCTGGCCGAAGCCAGAGCCGGCTCCCTCTGCTTGCGGGGAAGTGTGGAGGGAGAGGCGGGTGTGGGAACTGGGGCTGCGCGCAGCGCTCGCCAGCCAGCGCGAGTTCCAGGTGGGCGCGGGCTCAGCGGGCCCCGCACCCCCGGCCCCGGGCAGTCAGGGGCCTAGCACCCGGGCCAGCAGCTGCAGAGGGTGCGCCGGGTCCCCCAGCACTGCCGGCCCGCCTGCACCCCGCTTGAATTCTCACCGGGCCCCAGCCGCCCTGCACAGGGCAAGGCTCAGGACCTGCAGCCCGCCATGCCCGAGCCCCCTCCCAACCCCTGTGAGCTCCAGCGTGGCCTGAGCCTCCCCGACGGGCACCGCCCCCTGCTCCTCAGCGCCCGGTCCCATCGACTGCCCAAGGGCTGAGAGGAGTGCAGGCGCCCGGCACAGCCCTGCGCAGGATCCACTAGGTGAAGCCAGCTGGGCTCCTGAGTCAGATGGGGACTTGGAAAACTTTTATGTCTAGCCTGAGGATTTTATATGCACCAGTCAGCACTCTGTGTCTAGCTTGGGGTTTGGGGATGCACCAATCAGCACTCTGTATCTAGCTAATCTGGTGGGCACTTGGAGAACTTCTGTGTCTAGCTAAAGGATTGTAAATGCACCAATCAGTGCTCTGTGTCTAGCTCAAGGTTTGCAAATGCACCAATCAGCACTCTGTGTCTAGCTAAAGGTTTGTAAACGCACCAATCAGTGCTCTGTGTCTAGCAAATGTAGTGGGGACTTGGAGAATTTTTATGTCTAGCTAGAGGATTGTAAATGCACCAATCAGCACTCTGTGTATATCTAGCTCAGGGATTGTAAATGCACCAATCAGCACCCTGTCAAAACGGACCAATTAGCTCTCTGTAAAATGGACCAATCAACAGGATGTGGGTGGGGTCAGATAAGGGAATAAAAGCAGGCTGCCCCGCTGGGTGCCAGTGGCTCACACCTGTAATCCCAGCAATTTGGGAGGCCTAGAGGGGTGGATCACGAGGTCAAGAGATCGAGACCATCCTGGCTAACACAGTGAAACCCCGACTCTACTAAAAAGACAAAATATTAGCTGGGTGCGGTGGTGGGTGCCTGTAATCCCCTCTACTGGGGAGGTTGAGGCAGGAGAATGGCGTGAACCCGGGAGGCGGAGCTTGCAGTGAGCCCAGATTGCACCACTGCATTCCAGCCTGGGTGACAGAGGGAGACTCCATCTCAAAAAAAAAAAAAAAAAAAAAAAAAAATGCAGGCTGCCTGAGCCAGCAGCAGCAACCCGCTCTGGTCTCCTTCCACGCTGTGGAAGCTTTGTTCTTGTGCTCTTTGCAATAAATCTTGCTGCTGCTCACTCTTTGGGTCCGCATAGCATTTATCTGCTGGTAACACCGACCGCAGAGGTCTGCAGCTTCA"
# BRCA1 variant seq
var = "TTAAACACTTTTCAAACCAGGCAATATTTTAGGCCTACTGTATATTTGCATTTTGAGCTTCCAATACGGATAAGTGACTGGAAAAAGCAGCTAGGTTTAGGTTGAAAAACAACAACCCACCGGGGAACACATTTTAGCAAATTCTTCTGAAAGTCAAAAATGTTATAGTCATAGGTAAAAAGTTACAAAGAACTACCAATTGTCAGAAATAGCTGCCAATATTGACTTAGAAGACAGCAGAAGGAATTTTAGTTCAAGAAACCTAAAACAGGCTGAAAACCTTACCTACCCTATAGCTACCACAAATAACACTGTTTCCAGTCATGATCATTCCTGATCACATATTAAGACATAACTGCAAATTGTGCTATACTGTACTATATTAAAAGGAAGTGAAATATGATCCCTATCCTAGAACTTTCCATACAAATGAATGTAAAACACCATAAAAATTAATCTTAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGTGGGCGGATCACGAGGTCAGGAAGTGGAGACCATCCTGGCTAACACGGTGAAACCCCGTCTCTACTAAAAATACAAAAAATTAGCCGGGCGTGGTGGTGGACGCCTGTAGTCCCAGCTACTTGGGGGGCCGAGGCAGGAGAATGGCGTGAACCCGGGAGGCGGAGCTTGCAGTGAGCCGAGATGGCGCCACTGCACTCCGGCCTGGGTGAAAGAGCGAGACTCCGTCTCAAAAACAAAACAAACAAAAATTAATCTTAAGCCAGGCGCAGTGGCTCACGCCAGCACTTTGGAAGGCCGAGGCGGGTGGATCACGAGATCAGGACTTCAAGACCAGCCTGACCAACGTGATGAAACCCTATCTCTACTAAAAATACAAAATTAGCCGGCCACGGTGGCGTGCGCCTATAATCCCAGCTACTCAGGAGGCTGAGGCAGGAGAAGCGCTTGAACTTGAACCTGGCAGGCGGAGGTTGCAGTGAGCCAAGATGGCGCCACTGCACTCCAGCCTGGGCGACAGAGCCAGACTCCAACCCCCCACCCCGAAAAAAAAAGGTCCAGGCCGGGCGCAGTGGCTCAGGACTGTAATCCCAGCACTTTGGAAGGCTGAGGCGGGTGGATCACAAGGTCAGGAGATCGAGACCATCTTGGCTAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAAATTAGCCGGGCATAGTGGTGGGCGCCTGTAGTCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATGGCCTGAACCCGGGAGGCGGAGCTGGCAGTGAGCCAAGATCGTGCCACTGCACTCCAGCCTAGGCAGCAGAGCGAGACCGTGTCTCAAAAAAACAAAACAAAACAAAACAAAAAGTCTGGGAGCGGTGGCTCACGCCTGTAATCCCAGCACTTTCGGAGGCCAAGGCAGGAGGATCACCTGAGGTCAGGAGTTCGAGACCAACCTGACCAATATGGAGAAACCCTGTCTCTACTAAAAATACAAAATTAGCTGGTGTGATGGCACATGCCTGCAATCCCAGGTACTCCGGAGGCTGAGGCAGCAGAATTGCTTGAACCCGGGAGGTGGAGGTTGTAGTGAGCCGAGATTGTGCCACTGCACTCCAGCCTGGGCAACAAGAGCCAAAGTCTGTCTCAAAAAAAAAAAAAAAAAAAAAAAAAGAAATTAATCTTAACAGGAAACAGAAAAAAGCAATGAAAAGCTAGAAAACATAATAGTTGATTGAAAATAACAATTTAGCATTTTCATTCTTACATCTTTAATTTTTATGTATCTGAGTTTTTAATTGATGGTTTAATTTGCCAGAATGAGAAAGAACATCCTATTTTTATGACTCTCTCCCATGGAAATGAAACATAAATGTATCCAAATGCCACACTATTGAGGATTTTCCTGATCACTGATTGTCATGAGTAAGTTTTGTGCTTTTTCAAAAGCAGTTTTTTCCTACAATGTCATTTCCTGCTTCTCTGGCTCTGATTTTCAATAAATTGATAAATTGTGAATCCTGTTTTCCTCTTATTTTTGTTTAGCTATAATGTTGAAGGGCAAGGGAGAGGATGGTTATTTATAAATCTTGTATCGCTCTGAAAACACAACATACATTTTCCTTAATCTGATTAACTTGACTTCAAATATGAAAAACAACTTTCATAAAGCAGAAAAGAATTTACCCTTTTTTATTGTGGGTAAGAGGCAATGGTACAACTTTTCAACTTATTTTTTGAATGTTACTCACTACTAACCATCACCATATTTAAAAAAATTAAAGAACTAATTTAGTTTAGTTTATTATTTATTTGACAAATGTTTATTGAGTGGCAACTAGGTCCCAAGTACCGTTCTAACTACTGAACATACAGATGTATGTAAACAAAACAAAAATCCCATCCTGGAGTTTACATTCTGTGGGACTAGAGATAAAAAATGGATACATTACATAGAATGTCAGCTAGTAATCAGTGTTATGGAGAAGCAGCAGGAATAGAAGATAAAGTGTGTGCTGGGGGTGTGGTAATTTTAAATAGGGGTGTCTGGAAATGAAAAGGTGGTATTTCAATCAAGATTTTTAGACCATGGCTGGGTGCAATGGCTCAGGCCTGTAATCCCAGCACCTTGAGAGGCCAAGGGAGGGTAGATCACTTGAGGTCAGGAGTTTGAGACCAGCATGGCCAACATAGCAAAACCCTATCTCTACAACAGAAAAATACAAGAATGGCTGGACGCAGTGGCTTATGCCTGTAATCCTAGCACTTTGGGAGGCCCAGGCGGGTGGATCACAAGGTCAGGAGATCAAGACTATCCTGGCTAACACGGTGAAATCCCGCCTCTACTAAAAAAGAAAAAAAAATACAAAAAATTAGCCGGGCGTGGTAGTGGGTGCTTGTAGTCCCAGCTATTCAGGAGGCTCAGGCAGAAGAATGGCATGAACCCGGGAGGCAGAGTTTGCAGTGAGCTGAGATCGCGCCACTGCACTCCAGCCTGGGCAACAGAGCAAGACTCCATCTCAAAAAAAGAAAAAAAAATACAAAAATTAGCTGGGCATGGTGGTGCACACCTATCGTCCCTGCTACTCTGGAGGCTGAGGTGGGAGGATTGCTTGAGCCTGACGAGGTTGAGGCTGCAGTGAGCTGTGATAGCACCACTGCACTCCAGCCTCTCGACAGAGATCCTATATAAAAAAAAAACCTCTGCATTTCATTGTATGTAAATAAGTATGTAATTTCATTGTATGTACAGAGCCAGTTTCAAACAAAGGTTCTTCCAAATACCTATCCTCTCAACGACACCGATCATCCATGTTTTTTTTTTTTTTTTTTTTTTTTTGAGATGGAGTTTAGCTCTGTCGCTGGAGTTCAGTGGTGCCATATTGGCTCACAGCAACATCTGCCTCCTGGTTCAAGTGATTCTCCTGCCTCAGCCTCCTGAGTAGCTGGGATTACAGGCACATGCCACTACGCCCAGCTAATTTTTGTATTTTTAGTGGAGAGGGGGTTTCACCATGTTGGCCAGGATGGTCTCGATCTCCTGACCTCGTGATCCTACCACCTTGGCCTCCCAAAGTGCTGGGATTACAGGCATAAGCCACCGCCCTCGGCCTCATCCATGATTTTATTTTGCCATTTCAAGTGATGGAGCTTGTTTTAGAGCTGGAAGAAAAGCCAAAATGCCAGTTAATCTAAACTAGATTCCTGCCCCAGTGCAGAACCAATCAAGACAGAGTCCCTGTCTTTCCCGGACCACAGGATTTGTGTTGAAAAGGAGAGGAGTGGGAGAGGCAGAGTGGATGGAGAACAAGGAATCATTTTCTATATTTTTAAAGTTCTTCAGTTAAGAAAATCAGCAATTACAATAGCCTAATCTTACTAGACATGTCTTTTCTTCCCTAGTATGTAAGGTCAATTCTGTTCATTTGCATAGGAGATAATCATAGGAATCCCAAATTAATACACTCTTGTGCTGACTTACCAGATGGGACACTCTAAGATTTTCTGCATAGCATTAATGACATTTTGTACTTCTTCAACGCGAAGAGCAGATAAATCCATTTCTTTCTGTTCCAATGAACTCTAACACATTAGAAAAACATATATATATATCTTTTTAAAAGGTTTATAAAATGACAACTTCATTTTATCATTTTAAAATAAAGTAAATTTAAGATTTGGAAGGTTTTAGAATAATACAAACCAAAGAACTAATGACAACGTCCTTTATTTTTAAAGATTCTAGAAGTTGCTTTTTGTAATTAGACAACATAAATTCTGAATTTTTTCACATATTGCTGCCAACCCCTTGGGTCTTTTCCTTTCTCCAAGAAAGAGAAAGCTACAGAGGAGTGACTGACCGGGTAGGTGGTGGTAGCCTTAGCTTTCTCCAATGTTTCTGGTTGTTTTCTTTTTCTTGCATAAAACCAAAATCAACAACGACCAAACCAACACCAATCAAGGCCTCCCCGCCCCTAACCTTTCCCAGTGACCTGCTCTCATCTCTGGATCCTCCTCAAGCACATCCCTGCCGGCAGCATCTGTTACTACTGACGCTCCTCTACTTCCCTCTTGCGCTTTCTCAATGGCGCAAATGGATCCAGTTCTTAAGTTCTCCCTCCCACAAAATCCTGTCTCCTCCCCTTCCCAGACATATTCCTGGCACCTCTTCTTCCACAAGGTCCCATCCTCTCATACATACCAGCCGGTGTTTTTTGTTTTGTTTTGTTTTGTTTTGTTTTGAGACAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAATGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCTAGCGATTCTCCTGCCTCAGCCTCCTGAGTAGCTGGAGCGGCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGAGTTTCACCACGTTGGTCAGGCTGGTCTGGAACTCCTGACCTCATGACCAGCCGACGTTTTTAAAGACATAGTGTCCCCCTCAAGGCATATTCCAGTTCCTATCACGAGGATTCCCCCACGGACACTCAGTGCCCCCTTCCTGATCCTCAGCGCTTCCCTCGCGACCTACAAACTGCCCCCCTCCCCAGGGTTCACAACGCCTTACGCCTCTCAGGTTCCGCCCCTACCCCCCGTCAAAGAATACCCATCTGTCAGCTTCGGAAATCCACTCTCCCACGCCAGTACCCCAGAGCATCACTTGGGCCCCCTGTCCCTTTCCCGGGACTCTACTACCTTTACCCAGAGCAGAGGGTGAAGGCCTCCTGAGCGCAGGGGCCCAGTTATCTGAGAAACCCCACAGCCTGTCCCCCGTCCAGGAAGTCTCAGCGAGCTCACGCCGCGCAGTCGCAGTTTTAATTTATCTGTAATTCCCGCGCTTTTCCGTTGCCACGGAAACCAAGGGGCTACCGCTAAGCAGCAGCCTCTCAGAATACGAAATCAAGGTACAATCAGAGGATGGGAGGGACAGAAAGAGCCAAGCGTCTCTCGGGGCTCTGGATTGGCCACCCAGTCTGCCCCCGGATGACGTAAAAGGAAAGAGACGGAAGAGGAAGAATTCTACCTGAGTTTGCCATAAAGTGCCTGCCCTCTAGCCTCTACTCTTCCAGTTGCGGCTTATTGCATCACAGTAATTGCTGTACGAAGGTCAGAATCGCTACCTATTGTCCAAAGCAGTCGTAAGAAGAGGTCCCAATCCCCCACTCTTTCCGCCCTAATGGAGGTCTCCAGTTTCGGTAAATATAAGTAATAAGGATTGTTGGGGGGGTGGAGGGAAATAATTATTTCCAGCATGCGTTGCGGAATGAAAGGTCTTCGCCACAGTGTTCCTTAGAAACTGTAGTCTTATGGAGAGGAACATCCAATACCAGAGCGGGCACAATTCTCACGGAAATCCAGTGGATAGATTGGAGACCTGTGCGCGCTTGTACTTGTCAACAGTTATGGACTGGAGTGTTATGTTTTCGTATTTTGAAAGCAGAAACTAGGCCTTAAAAAGATACGTACAACTCTTTAGGGAGACTACAATTCCCATCCAGCCCCAGGAGTCTGGGGCAAGTAGTCTTGTAAGGTCAGTGGCCTGCGGGGACGCAGTGAGCGCCGAATTTGCCTGGGGCAGGGGAAATGCGCTCTGGCCCATGTCTGCGCACTCGTAGTTCCACCCCTCAGCCCCAGTGTTTGTTATTTTTCGGGTTCAGCTTGCTTTTGCCCCGTCTCCGTCGACGCAATCGCCACCAGTCAATGGGGTGGTCGTTTTGAGGGACAAGTGGTAAGAGCCAATCTTCTTGGCGAAAACGCGGAGAAACGGGACTAGTTACTGTCTTTGTCCGCCATGTTAGATTCACCCCACAGAGATAGCGGCAGAGCTGGCAGCGGACGGTCTTTGCATTGCCGCCTCCCCAGGGGGCGGGAAGCTGGTAAGGAAGCAGCCTGGGTTAGCTAGGGGTGGGGTCACGTCACACTAAGAGGGTTTGGAGAAGTTCAAGGGAGGAATCCTGCAAAGAAGAGGGGCGACTTTTTCCGTGTCTCCGGACAGCTAATCGTTTTAGTGACAGGATGAGAGAGCCCTTCGTGTTCTGAGGGACCGAGTGGGCGAAAAGCGCCGGAGAGTTGGAGAGTCTGTGGTTCAGAATGCGAGGTGACAACGTGCTAGCAGCCCTCGCTCGCTCTCGGCGCCTCCTCGGCCTTGGCGTCCATTCTGGCCGTGCTGGAGGAGCCCTTCAGCCCGCCACTGCGCTGTGGGGGCCCCTCTCTGGGCTGGCCGAAGCCAGAGCCGGCTCCCTCTGCTTGCGGGGAAGTGTGGAGGGAGAGGCGGGTGTGGGAACTGGGGCTGCGCGCAGCGCTCGCCAGCCAGCGCGAGTTCCAGGTGGGCGCGGGCTCAGCGGGCCCCGCACCCCCGGCCCCGGGCAGTCAGGGGCCTAGCACCCGGGCCAGCAGCTGCAGAGGGTGCGCCGGGTCCCCCAGCACTGCCGGCCCGCCTGCACCCCGCTTGAATTCTCACCGGGCCCCAGCCGCCCTGCACAGGGCAAGGCTCAGGACCTGCAGCCCGCCATGCCCGAGCCCCCTCCCAACCCCTGTGAGCTCCAGCGTGGCCTGAGCCTCCCCGACGGGCACCGCCCCCTGCTCCTCAGCGCCCGGTCCCATCGACTGCCCAAGGGCTGAGAGGAGTGCAGGCGCCCGGCACAGCCCTGCGCAGGATCCACTAGGTGAAGCCAGCTGGGCTCCTGAGTCAGATGGGGACTTGGAAAACTTTTATGTCTAGCCTGAGGATTTTATATGCACCAGTCAGCACTCTGTGTCTAGCTTGGGGTTTGGGGATGCACCAATCAGCACTCTGTATCTAGCTAATCTGGTGGGCACTTGGAGAACTTCTGTGTCTAGCTAAAGGATTGTAAATGCACCAATCAGTGCTCTGTGTCTAGCTCAAGGTTTGCAAATGCACCAATCAGCACTCTGTGTCTAGCTAAAGGTTTGTAAACGCACCAATCAGTGCTCTGTGTCTAGCAAATGTAGTGGGGACTTGGAGAATTTTTATGTCTAGCTAGAGGATTGTAAATGCACCAATCAGCACTCTGTGTATATCTAGCTCAGGGATTGTAAATGCACCAATCAGCACCCTGTCAAAACGGACCAATTAGCTCTCTGTAAAATGGACCAATCAACAGGATGTGGGTGGGGTCAGATAAGGGAATAAAAGCAGGCTGCCCCGCTGGGTGCCAGTGGCTCACACCTGTAATCCCAGCAATTTGGGAGGCCTAGAGGGGTGGATCACGAGGTCAAGAGATCGAGACCATCCTGGCTAACACAGTGAAACCCCGACTCTACTAAAAAGACAAAATATTAGCTGGGTGCGGTGGTGGGTGCCTGTAATCCCCTCTACTGGGGAGGTTGAGGCAGGAGAATGGCGTGAACCCGGGAGGCGGAGCTTGCAGTGAGCCCAGATTGCACCACTGCATTCCAGCCTGGGTGACAGAGGGAGACTCCATCTCAAAAAAAAAAAAAAAAAAAAAAAAAAATGCAGGCTGCCTGAGCCAGCAGCAGCAACCCGCTCTGGTCTCCTTCCACGCTGTGGAAGCTTTGTTCTTGTGCTCTTTGCAATAAATCTTGCTGCTGCTCACTCTTTGGGTCCGCATAGCATTTATCTGCTGGTAACACCGACCGCAGAGGTCTGCAGCTTCA"
input_length = len(var)
var_pos = int((len(var) / 2) + 1)  # Explicitly cast to integer
region = "BRCA1"
# Generate embeddings 
dataset_ref = evo2.process_data([ref])
embedding_ref = evo2.get_embeddings(dataset_ref)
dataset_var = evo2.process_data([var])
embedding_var = evo2.get_embeddings(dataset_var)

var_pos = 1
# Refernece embedding at specific variant position
first_embedding1 = embedding_ref['embeddings'][0]
print(f"Shape of first embedding: {first_embedding1.shape}")
selected_ref = first_embedding1[var_pos]
print(f"Shape: {selected_ref.shape}") # Shape: (4096,)

# variant embedding at specific variant position
first_embedding = embedding_var['embeddings'][0]
print(f"Shape of first embedding: {first_embedding.shape}")
selected_var = first_embedding[var_pos]
print(f"Shape: {selected_var.shape}") # Shape: (4096,)

# Join both embeddings together; Convert both embeddings to DataFrames
if selected_ref.shape == selected_var.shape:
    df1 = pd.DataFrame(selected_ref, columns=["ref_embedding"])
    df2 = pd.DataFrame(selected_var, columns=["var_embedding"])
    
    # Concatenate the DataFrames column-wise
    final_df = pd.concat([df1, df2], axis=1)
    final_df["delta_embedding"] = final_df["ref_embedding"] - final_df["var_embedding"]
    final_df.insert(0, "input_length", input_length)  # Add input_length as the first column
    final_df.insert(1, "var_pos", var_pos)         # Add var_pos as the second column
    final_df.insert(2, "region", region)         # Add var_pos as the second column
    outfile = f"{region}_pos{var_pos}.xlsx"
    final_df.to_excel(outfile, index=False)
else:
    print("Error: The embeddings do not have the same shape.")





# Reduce dimensionality for plotting (e.g., average over the sequence dimension)
ref_embedding_mean = np.mean(ref_embedding, axis=0)
var_embedding_mean = np.mean(var_embedding, axis=0)
plt.figure(figsize=(10, 6))
plt.plot(ref_embedding_mean, label="Reference Sequence", linestyle="--", marker="o")
plt.plot(var_embedding_mean, label="Variant Sequence", linestyle="--", marker="x")
plt.title("Comparison of Embeddings")
plt.xlabel("Embedding Dimension")
plt.ylabel("Embedding Value")
plt.legend()
plt.show()
plt.savefig("embedding_comparison.png", dpi=300, bbox_inches="tight")  # Save with high resolution

# NEW

import pandas as pd
import numpy as np

# Example embedding arrays (replace these with your actual embeddings)
# Assuming embeddings are 1D NumPy arrays of length 8192
ref_embedding = embedding_ref["embeddings"][0]  # Replace with actual reference embedding
var_embedding = embedding_var["embeddings"][0]  # Replace with actual variant embedding


# Print embeddings
for i, seq in enumerate(ref_embedding):
    last_embedding = ref_embedding["embeddings"][i][ref_embedding["original_lengths"][i] - 1]
    print(f"Last embedding for sequence {i + 1}: {last_embedding}")
    print(f" Dim: {last_embedding.shape}")

# Get the total number of sequences
num_sequences = len(var_embedding)
print(f"Total number of nucleotides: {num_sequences}")
assert len(ref_embedding) == len(var_embedding), "Embeddings must have the same length!"

# Initialize a list to store results
results = []
# Compare reference and variant embeddings at each position
for i in range(len(ref_embedding)):
    ref_value = ref_embedding[i]
    var_value = var_embedding[i]
    
    # Append values to results
    results.append({
        "Position": i + 1,  # 1-based position
        "Reference embedding value": ref_value,
        "Variant embedding value": var_value
    })
# Convert results to a DataFrame
results_df = pd.DataFrame(results)
print(f"Results DataFrame created with {len(results_df)} rows.")
results_df.to_csv(f"BRCA1_embed_diff.csv", index=False)
print("Results saved to 'BRCA1_embed_diff.csv'.")

################################################
# 4. Loop Through Subsets of Input Sequences
################################################

# Define the sequence and subset lengths
input_sequence = "ACGTTTATCGTA" * 5000  # Length = 60,000
subset_lengths = [100, 200, 300, 400, 500, 600, 1000, 2000, 3000, 4000,5000,60000]  # Different lengths to test

results = []
for length in subset_lengths:
    subset_sequence = input_sequence[:length]  # Take the first `length` nucleotides
    start_time = time.time()
    dataset_subset = evo2.process_data([subset_sequence])  # Process data
    embeddings_subset = evo2.get_embeddings(dataset_subset)  # Get embeddings
    end_time = time.time()
    
    # embedding dimensions
    embedding_dim = embeddings_subset["embeddings"][0].shape  # Access shape directly
    results.append({
        "Length": length,
        "Embedding Dimension": embedding_dim,
        "Time (s)": end_time - start_time
    })

# Save results into a DataFrame
results_df = pd.DataFrame(results)
print(results_df)
results_df.to_excel("/workspace/embedding_runtime.xlsx", index=False)

# print current directory   
print(f"Current directory: {os.getcwd()}")

# print all files in the current directory
print("Files in current directory:")
for file in os.listdir("."):
    print(file)

# bash
docker exec -it a643f0fcee3b ls /workspace
docker cp a643f0fcee3b:/workspace/embedding_runtime.xlsx /tmp/embedding_runtime.xlsx
docker cp /tmp/embedding_runtime.xlsx c3b18d465a12:/root/verb-workspace/embedding_runtime.xlsx


################################################
# Example Usage For Sequence Generation
################################################

from helical.models.evo_2 import Evo2, Evo2Config
evo2_config = Evo2Config(batch_size=1)
evo2 = Evo2(configurer=evo2_config)
sequences = ["ACGT" * 1000]
dataset = evo2.process_data(data)
generate = evo2.generate(dataset)
print(generate)



